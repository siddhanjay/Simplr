"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const abi_1 = require("./abi");
const ConfirmedTransaction_1 = require("./ConfirmedTransaction");
const sleep_1 = require("./sleep");
class TransactionPromise {
    constructor(rpc, contract, methodABI, params, opts) {
        this.rpc = rpc;
        this.contract = contract;
        this.methodABI = methodABI;
        this.params = params;
        this.opts = opts;
        this.calldata = abi_1.encodeInputs(methodABI, params);
    }
    async getTx() {
        if (this.tx) {
            return this.tx;
        }
        // make sure that only one sendToContract is called
        if (!this.sendToContractReq) {
            this.sendToContractReq = this.rpc.sendToContract(Object.assign({ address: this.contract.address, datahex: this.calldata }, this.opts));
        }
        const { txid } = await this.sendToContractReq;
        // make sure that only one getTransaction is called
        if (this.getTxReq) {
            return this.getTxReq;
        }
        this.getTxReq = this.rpc.getTransaction({ txid });
        this.tx = await this.getTxReq;
        return this.tx;
    }
    async exec() {
        // only send the transaction request once
        if (this.sent) {
            return;
        }
        this.sent = true;
        const { txid } = await this.rpc.sendToContract(Object.assign({ address: this.contract.address, datahex: this.calldata }, this.opts));
        this.txid = txid;
    }
    then(onfulfilled, reject) {
        return this.exec().then(async () => {
            const tx = await this.confirm(1);
            return tx;
        }).then(onfulfilled).catch(reject);
    }
    /**
     * Returns a transaction object that had been confirmed at least n times
     */
    async confirm(nConfirms = 3, timeout = 3000, txUpdated) {
        const hasTxWaitSupport = await this.rpc.checkTransactionWaitSupport();
        // TODO: a way to notify if tx had been added to wallet (after getTransaction returns)
        // if hasTxWaitSupport, make one long-poll per confirmation
        let confirmations = 1;
        // if !hasTxWaitSupport, poll every interval until tx.confirmations increased
        let lastConfirmation = 0;
        while (true) {
            const req = { txid: this.txid };
            if (hasTxWaitSupport) {
                req.waitconf = confirmations;
            }
            const tx = await this.rpc.getTransaction(req);
            if (tx.confirmations > 0) {
                const receipt = await this.rpc.getTransactionReceipt({ txid: tx.txid });
                if (!receipt) {
                    throw new Error("Cannot get transaction receipt");
                }
                const ctx = new ConfirmedTransaction_1.ConfirmedTransaction(this.contract.info.abi, tx, receipt);
                if (txUpdated && tx.confirmations > lastConfirmation) {
                    // confirmation increased since last check
                    confirmations = tx.confirmations;
                    txUpdated(ctx);
                }
                if (tx.confirmations >= nConfirms) {
                    // reached number of required confirmations. done
                    return ctx;
                }
            }
            lastConfirmation = tx.confirmations;
            if (hasTxWaitSupport) {
                // long-poll for one additional confirmation
                confirmations++;
            }
            else {
                await sleep_1.sleep(timeout + Math.random() * 200);
            }
        }
    }
}
exports.TransactionPromise = TransactionPromise;
