import { IABIMethod } from "./ethjs-abi";
import { IDecodedLog, ITransactionLog } from "./index";
import { IRPCCallContractResult, IRPCGetTransactionReceiptBase, IRPCGetTransactionResult, IRPCSendToContractResult, QtumRPC } from "./QtumRPC";
export interface IContractSendTx {
    method: string;
    txid: string;
}
export declare type IContractSendTxConfirmationHandler = (tx: IRPCGetTransactionResult, receipt: IContractSendTxReceipt) => any;
export declare type IContractSendTxConfirmFunction = (n?: number, handler?: IContractSendTxConfirmationHandler) => any;
export interface IContractSendTxConfirmable extends IRPCGetTransactionResult {
    method: string;
    confirm: IContractSendTxConfirmFunction;
}
export interface IContractInfo {
    /**
     * Contract ABI methods
     */
    abi: IABIMethod[];
    /**
     * Address of contract
     */
    address: string;
    name: string;
    deployName: string;
    txid: string;
    bin: string;
    binhash: string;
    createdAt: string;
    confirmed: boolean;
    sender: string;
}
export interface IContractCallDecodedResult extends IRPCCallContractResult {
    outputs: any[];
}
export interface IContractSendRequestOptions {
    /**
     * The amount in QTUM to send. eg 0.1, default: 0
     */
    amount?: number | string;
    /**
     * gasLimit, default: 200000, max: 40000000
     */
    gasLimit?: number;
    /**
     * Qtum price per gas unit, default: 0.00000001, min:0.00000001
     */
    gasPrice?: number | string;
    /**
     * The quantum address that will be used as sender.
     */
    senderAddress?: string;
}
export interface IContractCallRequestOptions {
    /**
     * The quantum address that will be used as sender.
     */
    senderAddress?: string;
}
export interface IContractSendTxReceipt extends IRPCGetTransactionReceiptBase {
    /**
     * logs decoded using ABI
     */
    logs: IDecodedLog[];
    /**
     * undecoded logs
     */
    rawlogs: ITransactionLog[];
}
export declare class Contract {
    private rpc;
    info: IContractInfo;
    address: string;
    private callMethodsMap;
    private sendMethodsMap;
    constructor(rpc: QtumRPC, info: IContractInfo);
    encodeParams(method: string, args?: any[]): string;
    /**
     * Call a contract method using ABI encoding, and return the RPC result as is. This
     * does not create a transaction. It is useful for gas estimation or getting results from
     * read-only methods.
     *
     * @param method name of contract method to call
     * @param args arguments
     */
    rawCall(method: string, args?: any[], opts?: IContractCallRequestOptions): Promise<IRPCCallContractResult>;
    call(method: string, args?: any[], opts?: IContractCallRequestOptions): Promise<IContractCallDecodedResult>;
    /**
     * Create a transaction that calls a method using ABI encoding, and return the RPC result as is.
     * A transaction will require network consensus to confirm, and costs you gas.
     *
     * @param method name of contract method to call
     * @param args arguments
     */
    rawSend(method: string, args: any[], opts?: IContractSendRequestOptions): Promise<IRPCSendToContractResult>;
    confirm(tx: IContractSendTx, confirm?: number, onConfirm?: IContractSendTxConfirmationHandler): Promise<IContractSendTxReceipt>;
    send(method: string, args: any[], opts?: IContractSendRequestOptions): Promise<IContractSendTxConfirmable>;
    private _makeSendTxReceipt(receipt);
}
