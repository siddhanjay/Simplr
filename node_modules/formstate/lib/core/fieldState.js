"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mobx_1 = require("mobx");
var types_1 = require("./types");
var utils_1 = require("../internal/utils");
/**
 * Helps maintain the value + error information about a field
 *
 * This is the glue between the *page* and *field* in the presence of invalid states.
 */
var FieldState = (function () {
    function FieldState(_initValue) {
        var _this = this;
        this._initValue = _initValue;
        /** If the field has been touched */
        this.dirty = false;
        /**
         * Set to true if a validation run has been completed since init
         * Use case:
         * - to show a green color in the field if `hasError` is false
         **/
        this.hasBeenValidated = false;
        /**
         * Allows you to preserve the `_autoValidationEnabled` value across `reinit`s
         */
        this._autoValidationDefault = true;
        this.setAutoValidationDefault = function (autoValidationDefault) {
            _this._autoValidationDefault = autoValidationDefault;
            _this._autoValidationEnabled = autoValidationDefault;
            return _this;
        };
        this.getAutoValidationDefault = function () { return _this._autoValidationDefault; };
        this._autoValidationEnabled = this._autoValidationDefault;
        this.enableAutoValidation = function () {
            _this._autoValidationEnabled = true;
            return _this;
        };
        this.enableAutoValidationAndValidate = function () {
            _this._autoValidationEnabled = true;
            return _this.validate();
        };
        this.disableAutoValidation = function () {
            _this._autoValidationEnabled = false;
            return _this;
        };
        this._validators = [];
        this.validators = function () {
            var validators = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                validators[_i] = arguments[_i];
            }
            _this._validators = validators;
            return _this;
        };
        /**
         * onUpdate is called whenever we change something in our local state that is significant
         * - value
         * - $
         * - error
         */
        this.onUpdate = function (handler) {
            _this._onUpdate = handler;
            return _this;
        };
        this.executeOnUpdate = function () {
            _this._onUpdate && _this._onUpdate(_this);
        };
        this.onDidChange = function (handler) {
            _this._onDidChange = handler;
            return _this;
        };
        this.executeOnDidChange = function (config) {
            _this._onDidChange && _this._onDidChange(config);
        };
        this.setAutoValidationDebouncedMs = function (milliseconds) {
            _this.queueValidation = mobx_1.action(utils_1.debounce(_this.queuedValidationWakeup, milliseconds));
            return _this;
        };
        /** Trackers for validation */
        this.lastValidationRequest = 0;
        this.preventNextQueuedValidation = false;
        /** On change on the component side */
        this.onChange = function (value) {
            // no long prevent any debounced validation request
            _this.preventNextQueuedValidation = false;
            // Store local old value for onDidChange
            var oldValue = _this.value;
            // Immediately set for local ui binding
            _this.value = value;
            // Call on did change if any
            _this.executeOnDidChange({ newValue: value, oldValue: oldValue });
            _this.dirty = true;
            _this.executeOnUpdate();
            if (_this._autoValidationEnabled) {
                _this.queueValidation();
            }
        };
        /**
         * If the page wants to reinitialize the field with a new value,
         * it should call this function
         */
        this.reinitValue = function (value) {
            if (value === void 0) { value = _this._initValue; }
            // If a previous validation comes back ignore it
            _this.preventNextQueuedValidation = true;
            // This value vetos all previous values
            _this._autoValidationEnabled = _this._autoValidationDefault;
            _this.value = value;
            _this.error = undefined;
            _this.dirty = false;
            _this.hasBeenValidated = false;
            _this.$ = value;
            _this.on$Reinit();
            _this.executeOnUpdate();
        };
        this.validating = false;
        /**
         * Runs validation on the current value immediately
         */
        this.validate = function () {
            _this.lastValidationRequest++;
            var lastValidationRequest = _this.lastValidationRequest;
            _this.validating = true;
            var value = _this.value;
            return types_1.applyValidators(_this.value, _this._validators || [])
                .then(mobx_1.action(function (fieldError) {
                /**
                 * If validation comes back out of order then the result of this validation is not siginificant
                 * We simply copy the value from the last validation attempt
                 */
                if (_this.lastValidationRequest !== lastValidationRequest) {
                    if (_this.hasError) {
                        return { hasError: true };
                    }
                    else {
                        return {
                            hasError: false,
                            value: _this.$,
                        };
                    }
                }
                _this.validating = false;
                _this.hasBeenValidated = true;
                /** For any change in field error, update our error */
                if (fieldError != _this.error) {
                    _this.error = fieldError;
                }
                /** Check for error */
                var hasError = _this.hasError;
                /** If no error, copy over the value to validated value */
                if (!hasError) {
                    if (_this.$ !== value) {
                        _this.$ = value;
                        _this.on$ChangeAfterValidation();
                    }
                }
                /** before returning update */
                _this.executeOnUpdate();
                /** return a result based on error status */
                if (hasError) {
                    return { hasError: true };
                }
                else {
                    return {
                        hasError: false,
                        value: value
                    };
                }
            }));
        };
        this.queuedValidationWakeup = function () {
            if (_this.preventNextQueuedValidation) {
                _this.preventNextQueuedValidation = false;
                return;
            }
            _this.validate();
        };
        /**
         * Runs validation with debouncing to keep the UI super smoothly responsive
         * NOTE:
         * - also setup in constructor
         * - Not using `action` from mobx *here* as it throws off our type definitions
         */
        this.queueValidation = utils_1.debounce(this.queuedValidationWakeup, 200);
        /**
         * Composible fields (fields that work in conjuction with FormState)
         */
        this.on$ChangeAfterValidation = function () { };
        this.on$Reinit = function () { };
        this.setCompositionParent = function (config) {
            _this.on$ChangeAfterValidation = config.on$ChangeAfterValidation;
            _this.on$Reinit = config.on$Reinit;
        };
        mobx_1.runInAction(function () {
            _this.value = _initValue;
            _this.$ = _initValue;
            /**
             * Automatic validation configuration
             */
            _this.queueValidation = mobx_1.action(utils_1.debounce(_this.queuedValidationWakeup, 200));
            _this._autoValidationEnabled = true;
        });
    }
    Object.defineProperty(FieldState.prototype, "hasError", {
        get: function () {
            return !!this.error;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "value", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "error", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "dirty", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "$", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "hasBeenValidated", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "_autoValidationDefault", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "setAutoValidationDefault", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "getAutoValidationDefault", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "_autoValidationEnabled", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "enableAutoValidation", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "enableAutoValidationAndValidate", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "disableAutoValidation", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "validators", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "onUpdate", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "executeOnUpdate", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "onDidChange", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "executeOnDidChange", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "setAutoValidationDebouncedMs", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "lastValidationRequest", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "preventNextQueuedValidation", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "onChange", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "reinitValue", void 0);
    __decorate([
        mobx_1.observable
    ], FieldState.prototype, "validating", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "validate", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "queuedValidationWakeup", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "on$ChangeAfterValidation", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "on$Reinit", void 0);
    __decorate([
        mobx_1.action
    ], FieldState.prototype, "setCompositionParent", void 0);
    return FieldState;
}());
exports.FieldState = FieldState;
